
SEXML-OBJECTS

sexml-objects is an extention to the sexml package that adds CLOS classe support
for the tags defined in the DTD that sexml uses for generating its renderer 
functions. In other words: if you had a function called div that rendered the 
markup for a html div, you can now have that function and a class that 
represents the div tag and all its attributes that can be used to generate the
markup for the div.

--------------------------------------------------------------------------------

HOW TO USE

To start useing sexml-objects you need a DTD. there is a html5.dtd included with
the sexml package that you can use. To generate the functions and classes from
that DTD this is what you should do:

CL-USER> (asdf:load-system :sexml-objects)

CL-USER> (in-package :sexml-objects)
#<PACKAGE "SEXML-OBJECTS">


;; define a layer where we will put our widget classes
SEXML-OBJECTS> (contextl:deflayer widget-classes)
#<CONTEXTL:STANDARD-LAYER-CLASS WIDGET-CLASSES {BE9BD41}>


;;what we are doing here is basically defining a layered-method (read macro :P)
;;that sexml will run for each tag it finds in the DTD.
SEXML-OBJECTS> 
(contextl:define-layered-method sexml::entity-definition-forms
  :in-layer widget-classes
  :around (entity package)
  (let ((class-symbol (sexml::function-symbol entity package)))

;;define a class for each tag, they should inherit from widget feel free to add 
;;your own classes for more functionality. some usefull classes are included in
;;this system. check cl-binds and cl-changes.

    `((defclass ,class-symbol (sexml-objects:widget)

;;%render-func is the function used to generate the markup for the class, the 
;;default function is the one created with sexml

	((sexml-objects:%render-func :accessor sexml-objects:%render-func 
				     :initarg :%render-func 
				     :initform #',class-symbol)
	 ,@(loop for attribute-string in (sexml::attributes entity)
	      for attribute-symbol = (sexml::argument-symbol attribute-string 
	      	  		     			     package)
	      for attribute-key = (sexml::argument-symbol attribute-string 
	      	  		  			  :keyword)

;;define reader and writer methods of each attribute. I use GET-* and SET-* 
;;methods to make it clear that they are sexml generated attribute methods

	      collect `(,attribute-symbol :reader ,(intern (concatenate 'string 
	      	      			  "GET-" (format nil "~A" 
					  	 attribute-symbol)))
					  :writer ,(intern (concatenate 'string 
					  "SET-" (format nil "~A" 
					  	 attribute-symbol)))
					  :initarg ,attribute-key :initform nil

;;this is some functionality provided by the cl-attribs that allows us to 
;;define attributes for the slots of a class, these attribs are used by
;;sexml-objects to render the markup for the class.
;;the :html-attrib-p tells sexml-objects that this slot contains a attribute
;;that should be inserted in the markup. :keyword is the keyword that will be
;;sent to the %render-func along with the value of this slot. 

					  :attributes (:html-attrib-p t :keyword 
					  	      ,attribute-key))))

;;the attributes-class is the metaclass for every object that sexml-objects
;;creates

	(:metaclass cl-attribs:attributes-class))
      ,@(call-next-method))))
#<CONTEXTL:LAYERED-METHOD ENTITY-DEFINITION-FORMS #<LAYER WIDGET-CLASSES 
			    			  	  {C25BD21}>
			  		   (:AROUND) (#<BUILT-IN-CLASS T>
                                                      #<BUILT-IN-CLASS T>) 
							      {C256EB9}>

;;now we need to tell sexml what DTD we want to be used to generate functions
;;and classes.

;;this is the layer that we
;;put our layered-method in

SEXML-OBJECTS> (contextl:ensure-active-layer 'widget-classes)

;;now the magic form:

SEXML-OBJECTS> 
(sexml:with-compiletime-active-layers (sexml:standard-sexml 
				      sexml-objects:widget-classes)
  (sexml:support-dtd (asdf:system-relative-pathname :sexml "html5.dtd") :<))

;;note that we define what package to put all the functions and classes in
;;in this case we tell sexml to put the generated stuff in the "<" package
;;this is to keep your working package clean and prevent conflicts with other
;;things you might have defined yourself, or imported from other packages


--------------------------------------------------------------------------------

OK NOW WHAT?

now lets try and use what we created:


SEXML-OBJECTS> 
(defparameter obj (make-instance '<:div :id "my new div" 
	       	 		 :%children
				 (list
				 "this is a literal text that is put inside the 
				 parent div"
				 (make-instance '<:br)
				 (make-instance '<:input :type "button" 
				 			 :value "press me!"))))
OBJ

now we have an object we can use to render markup for the div and any children
inside it.

SEXML-OBJECTS> (render-markup obj)
"<div id=\"my new div\">this is a literal text that is put inside the 
				 parent div<br/><input type=\"button\"
				 value=\"press me!\"/></div>"

--------------------------------------------------------------------------------

WHAT ELSE?

%ID
every object created with sexml-objects is automatically given a numbered id:

SEXML-OBJECTS> (%id obj)
"DIV-4"

note that id and %id are two different slots, %id is the one defined and used by
sexml-objects itself, but id is the attribute that is defined from DTD for
markup rendering.


%CHILDREN
any child inside an object must be in a list in the %children slot of the object.

SEXML-OBJECTS> (%children obj)
("this is a literal text that is put inside the 
				 parent div"
 #<<:BR {F0F32C1}> #<<:INPUT {F0F32D1}>)


WIDGETP
quit obvius!

SEXML-OBJECTS> (widgetp obj)
T


MAP-WIDGET
maps the given function to the widget tree returns non nil values. that is every 
child of the given widget and the children of the children...

SEXML-OBJECTS> (map-widget obj
			   (lambda (o)
			     (if (widgetp o)(%id o))))
("INPUT-1" "BR-1")


GET-HTML-ATTRIBUTES
returns a plist containing any attributes defined for the object that has non nil 
value, with the keyword used to render it.

SEXML-OBJECTS> (get-html-attributes obj)
(:ID "my new div")


ADD-CHILD
adds the given child to the children list of the given object. accepts optional
index and from-end values.

SEXML-OBJECTS> (defparameter obj2 (make-instance '<:div))
OBJ2
SEXML-OBJECTS> (add-child obj obj2)
("this is a literal text that is put inside the 
				 parent div"
 #<<:BR {F0F32C1}> #<<:INPUT {F0F32D1}> #<<:DIV {D08C421}>)



%PARENT
every object has a parent slot. if the object is inside another objects children
list its %parent slot will be set to the parent object. or nil if its not inside
any other object.

SEXML-OBJECTS> (%parent obj2)
#<<:DIV {F0A2991}>


REMOVE-CHILD
removes the given child or the child at the given index from beginning or the
end of the child list. 

SEXML-OBJECTS> (remove-child obj obj2)
("this is a literal text that is put inside the 
				 parent div"
 #<<:BR {F0F32C1}> #<<:INPUT {F0F32D1}>)

--------------------------------------------------------------------------------

ADVANCED STUFF

there are a few things you might wanna modify for your own need to get the most
out of sexml-objects.

%render-func
this is a slot that the function refrenced by its value is used to get the 
markup for the object and its children.

render-murkup
this is a generic method so you can specialize it or define :bfore :after methods

for example:
this is the way i make a special check-box that manages its own label with the 
value given in its %label slot

(defclass check-box (<:input)
  ((<::type    :reader   get-type    :writer  set-type :initarg  :type :initform   "checkbox")
   (%label     :accessor %label      :initarg :%label  :initform ""))
  (:metaclass attributes-class))

(defmethod render-markup ((check-box check-box))
  (concatenate 'string
	       (call-next-method)
	       (render-markup (make-instance '<:label :for (get-id check-box)
					     :%id (concatenate 'string (%id check-box) "-LABEL")
					     :%children (%label check-box)))))

thing to note about this:

i redefine type slot to have a initform of "checkbox" so that i wont need to
give it on the make-instance form. as the symbol is internal inside the "<"
package i use <::type for redefining it.

:metaclass should be attributes-class as for any sexml-objects class

then i specialize the render-markup to include the markup for the label.

check-box should have an id for the label to work.

usage:

SEXML-OBJECTS> (make-instance 'check-box :%label "test label" :id "cb")
#<CHECK-BOX {CDE2D11}>
SEXML-OBJECTS> (render-markup *)
"<input id=\"cb\" type=\"checkbox\"/><label for=\"cb\">test label</label>"

--------------------------------------------------------------------------------

Contact Info

If u find bugs or have any idea about making sexml-objects better please contact
me at:

farzadbekran@gmail.com

--------------------------------------------------------------------------------

Copyright (c) 2012 Farzad Bekran


Permission is hereby granted, free of charge, to any person obtaining a copy of this
software and associated documentation files (the "Software"), to deal in the Software
without restriction, including without limitation the rights to use, copy, modify, 
merge, publish, distribute, sublicense, and/or sell copies of the Software, and to 
permit persons to whom the Software is furnished to do so, subject to the following 
conditions:

The above copyright notice and this permission notice shall be included in all copies 
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
PARTICULAR PURPOSE AND NONINFRINGEMENT. 

IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.
